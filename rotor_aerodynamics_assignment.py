# -*- coding: utf-8 -*-
"""rotor_aerodynamics_assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j7yyqqiu0aPtEGgfdpLXn6CjISlaJ0pc

#Importing required Libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

"""#Aircraft Fuselage Parameters from the user

"""

#fuselage parameters
def get_fuselage_parameters():
  fuselage={}
  fuselage["mass"]=float(input("Please enter the mass of the fuselage:"))
  fuselage["length"]=float(input("Please enter the length of the fuselage:"))
  fuselage["width"]=float(input("Please enter the width of the fuselage:"))
  fuselage["height"]=float(input("Please enter the height of the fuselage:"))
  fuselage["CL"]=float(input("Please enter the CL of the fuselage:"))
  fuselage["CD"]=float(input("Please enter the CD of the fuselage:"))
  return fuselage

"""# Aircraft engine parameters"""

#Engine parameters
def get_engine_parameters():
  engine={}
  engine["mass"]=float(input("Please enter the mass of the engine:"))
  engine["BSFC"]=float(input("Please enter the BSFC of the engine:"))
  engine["shaft power conversion efficiency"]=float(input("Please enter the shaft power conversion efficiency:"))
  engine["fractional power tail rotor"]=float(input("Please enter the fractional power of the tail rotor:"))
  return engine

"""#Rotor Assembly characteristics

"""

def get_rotor_parameters():
    rotor = {}
    rotor["number_of_blades"] = int(input("Please enter the number of rotors: "))
    rotor["rotor_omega"] = float(input("Please enter the angular velocity of the rotor (rad/s): "))#rotor_omega=2*np.pi*rotor_rpm/60
    rotor["blade_mass"] = float(input("Please enter the mass of the rotors (kg): "))
    rotor["NACA_for_airfoil"] = input("Please enter the NACA number of the airfoil: ")
    rotor["radius_of_rotors"] = float(input("Please enter the radius of the rotors (m): "))
    rotor["root_cutout"] = float(input("Please enter the root cutout of the rotors (m): "))
    rotor["angle_of_attack"] = float(input("Please enter the angle of attack (degrees): "))
    rotor["root_chord"] = float(input("Please enter the root chord (m): "))
    rotor["tip_chord"] = float(input("Please enter the tip chord (m): "))
    rotor["root_pitch"] = float(input("Please enter the root pitch (degrees): "))
    rotor["slope_pitch"] = float(input("Please enter the slope of the pitch: "))
    rotor["climb_velocity"] = float(input("Please enter the desired climb velocity (m/s): "))
    return rotor

rotor_params = get_rotor_parameters()

number_of_blades = rotor_params["number_of_blades"]
rotor_omega = rotor_params["rotor_omega"]
blade_mass = rotor_params["blade_mass"]
NACA_for_airfoil = rotor_params["NACA_for_airfoil"]
radius_of_rotors = rotor_params["radius_of_rotors"]
root_cutout = rotor_params["root_cutout"]
angle_of_attack = rotor_params["angle_of_attack"]
root_chord = rotor_params["root_chord"]
tip_chord = rotor_params["tip_chord"]
root_pitch = rotor_params["root_pitch"]
slope_pitch = rotor_params["slope_pitch"]
climb_velocity = rotor_params["climb_velocity"]

"""#Setting atmospheric parameters"""

def get_atmosphere_parameters():
    atmosphere = {}

    atmosphere["temperature_sea_level"] = float(input("Please enter the sea level temperature (K): "))
    atmosphere["Reynolds_number"] = float(input("Please enter the Reynolds number: "))
    atmosphere["altitude"] = float(input("Please enter the altitude (m): "))
    atmosphere["pressure_sea_level"] = float(input("Please enter the pressure at sea level (Pa): "))
    atmosphere["Lapse_rate_troposphere"] = float(input("Please enter the lapse rate of the troposphere (K/m): "))
    atmosphere["Specific_gas_constant"] = 287.053   # constant
    atmosphere["gravitational_acceleration"] = 9.80665  # constant
    atmosphere["specific_heat_constant"] = 1.4      # constant
    atmosphere["wind_velocity"] = float(input("Please enter the wind velocity (m/s): "))
    atmosphere["ISA_OFFSET"] = float(input("Please enter the ISA offset (K): "))
    return atmosphere

# Example usage
atmosphere_params = get_atmosphere_parameters()
# Unpack into variables
temperature_sea_level = atmosphere_params["temperature_sea_level"]
Reynolds_number = atmosphere_params["Reynolds_number"]
altitude = atmosphere_params["altitude"]
pressure_sea_level = atmosphere_params["pressure_sea_level"]
Lapse_rate_troposphere = atmosphere_params["Lapse_rate_troposphere"]
Specific_gas_constant = atmosphere_params["Specific_gas_constant"]
gravitational_acceleration = atmosphere_params["gravitational_acceleration"]
specific_heat_constant = atmosphere_params["specific_heat_constant"]
wind_velocity = atmosphere_params["wind_velocity"]
ISA_OFFSET = atmosphere_params["ISA_OFFSET"]

"""# Computation of local parameters at a given altitude"""

def Temp(init_temp, ISA_Offset):
  T_new= temperature_sea_level-  Lapse_rate_troposphere*altitude+ ISA_OFFSET
  return T_new
def Pressure(Pressure_sea_level, T_new, Temperature_sea_level, Lapse_rate_troposphere):
  return Pressure_sea_level*((T_new/Temperature_sea_level)**(gravitational_acceleration/(Lapse_rate_troposphere*Specific_gas_constant)))
def speed_of_sound(temperature):    # function to calculate the speed of sound
  return np.sqrt(1.4*8.314*temperature)
def mach_number(velocity, speed_of_sound):
  return velocity/speed_of_sound
def density(temperature, pressure):
  return pressure/(287*temperature)

"""# Computing various coeffcients

"""

def Cl_Cd_Cm(naca_number, alpha):
    # Extract coefficients
    cl=5.75
    cd=0.013
    cm=0.03
    return cl,cd,cm
# Function to get chord_lenth and pitch at a given location.
def get_chord_length(x,radius_of_rotors,root_cutout, root_chord, tip_chord):
  chord_length_x=(root_chord -((root_chord-tip_chord)/(radius_of_rotors-root_cutout))*x)
  return chord_length_x
def pitch(root_pitch,slope_pitch ,x):# Basically involving twists
  local_pitch= root_pitch+ slope_pitch*x
  return np.deg2rad(local_pitch)

"""#Inflow for each blade section elementally

$$
\lambda =
\sqrt{
\left( \frac{\sigma a}{16F} - \frac{\lambda_c}{2} \right)^2
+ \frac{\sigma a}{8F} \, \theta \, \frac{r}{R}
}- \left( \frac{\sigma a}{16F} - \frac{\lambda_c}{2} \right)
$$

$$
\text{where,} \quad
\lambda_c = \frac{V}{\Omega R},
\quad
\lambda = \frac{V + v}{\Omega R}
$$

$$
F = \frac{2}{\pi}cos^{-1}(e^{-f})    ; where  f = \frac{b(1-\frac{r}{R})}{\lambda} \\
dT = 4\pi\rho rF(V+v)vdr = 4\pi\rho rF(\lambda ω r)(λωr - V)dr \\
T\ =\ b\int_{Rc}^{R}dT
$$

* we also include prandtl's tip loss model in the inflow ratio formula
* Since Lambda is dependent on F and f further is dependent on lamda we have to iteratively find out the value of Lambda until solutuion stabilizes.

#Define some useful parameters
"""

a=5.75
cm=0.1
rho=1.2
CD0=0.005
climb_velocity=0
lambda_c=climb_velocity/(rotor_omega*radius_of_rotors)
slope_pitch=-0.1

def elemental_inflow_ratio(r_distance, max_iter=100, tol=1e-6):
    # Initial guess values to start with
    F = 1.1
    lambda_inflow = 0.2

    for i in range(max_iter):
        theta = pitch(root_pitch, slope_pitch, r_distance)

        #  geting the  Cl (lift coefficient)

        sigma=number_of_blades*get_chord_length(r_distance, radius_of_rotors,root_cutout, root_chord, tip_chord)/(np.pi*radius_of_rotors)# since sigma is not constant
        # Update lambda_inflow using current F
        new_lambda_inflow = (
            np.sqrt(((sigma * a) / (16 * F) - (lambda_c / 2))**2
                    + (sigma * a) / (8 * F) * theta * (r_distance / radius_of_rotors))
            - ((sigma * a) / (16 * F) - (lambda_c / 2))
        )
        #print(new_lambda_inflow)

        # Update F using the new lambda_inflow (Gauss–Seidel step)
        f = (number_of_blades / 2) * ((1 - r_distance / radius_of_rotors) / lambda_inflow)

        new_F = (2 / np.pi) * np.arccos(np.exp(-f))

        #print(new_F)

        # Check convergence
        if abs(new_lambda_inflow - lambda_inflow) < tol and abs(new_F - F) < tol:
            return new_lambda_inflow, new_F

        # Update values for next iteration
        lambda_inflow, F = new_lambda_inflow, new_F

    return lambda_inflow, F

"""# Calculating the thrust from all rotors"""

x# we now compute the elemental thrust
def phi_r(r_distance):
  c=np.arctan((elemental_inflow_ratio(r_distance)[0])*radius_of_rotors/r_distance)
  return c
def alpha_effective_r(r_distance):
  d=pitch(root_pitch, slope_pitch, r_distance)-phi_r(r_distance)
  return d
def cL(r_distance):
  return a*alpha_effective_r(r_distance)
def cD(r_distance):
  return CD0+k*((a*(alpha_effective_r(r_distance)))**2)

def elemental_thrust(r_distance,dr):
  c,b=elemental_inflow_ratio(r_distance)
  density=1.38
  dT=4*np.pi*density*r_distance*(c*rotor_omega*radius_of_rotors)*((c*rotor_omega*radius_of_rotors)-climb_velocity)*dr
  return dT
def elemental_torque(r_distance,dr):
  return elemental_thrust(r_distance,dr)*r_distance
def total_thrust(n_divisions, number_of_blades):
  r=np.linspace(root_cutout, radius_of_rotors, n_divisions)
  delta_r=r[1]-r[0]
  store_dT=[]
  for i in range(1, n_divisions-1):
    store_dT.append(elemental_thrust(r[i],delta_r))
  net_thrust=number_of_blades*np.sum(store_dT)
  return net_thrust
def total_torque(n_divisions, number_of_blades):
  r=np.linspace(root_cutout, radius_of_rotors, n_divisions)
  delta_r=r[1]-r[0]
  store_dT=[]
  for i in range(1, n_divisions-1):
    store_dT.append(elemental_torque(r[i],delta_r)*r[i]+0.5*rho*cm*(rotor_omega*r[i])**2)
  net_moment=number_of_blades*np.sum(store_dT)
  return net_moment
def total_power(n_divisions, number_of_blades):
  r=np.linspace(root_cutout, radius_of_rotors, n_divisions)
  delta_r=r[1]-r[0]
  store_dT=[]
  for i in range(1, n_divisions-1):
    store_dT.append((elemental_thrust(r[i],delta_r))*(elemental_inflow_ratio(r[i])[0])*rotor_omega*r[i])
  net_power=number_of_blades*np.sum(store_dT)
  return net_power
def values(n_divisions, number_of_blades):
  b=number_of_blades
  r=np.linspace(root_cutout, radius_of_rotors, n_divisions)
  r_distance=r
  delta_r=r_distance[1]-r_distance[0]
  dL=0.5*rho*get_chord_length(r_distance,radius_of_rotors,root_cutout, root_chord, tip_chord)*cL(r_distance)*((rotor_omega*r_distance)**2+(elemental_inflow_ratio(r_distance)*rotor_omega*radius_of_rotors)**2)
  dD=0.5*rho*get_chord_length(r_distance,radius_of_rotors,root_cutout, root_chord, tip_chord)*cD(r_distance)*((rotor_omega*r_distance)**2+(elemental_inflow_ratio(r_distance)*rotor_omega*radius_of_rotors)**2)
  dT=(dL*np.cosine(phi_r(r_distance)) - dD*np.sine(phi_r(r_distance)))*delta_r
  dFx=(dD*np.cosine(phi_r(r_distance)) + dL*np.sine(phi_r(r_distance)))*delta_r
  dP=rotor_omega*r_distance*dFx
  dtorque=r_distance*dFx
  Thrust = np.sum(dT) * b
  Torque = np.sum(dtorque) * b
  Power  = np.sum(dP) * b
  Thrust_x= np.sum(dFx) * b
  lift= np.sum(dL)
  drag= np.sum(dD)

c=total_thrust(100,3)
d=total_torque(100,3)#per blade
e=total_power(100,3)
print(c,d,e)
rotor_omega=30

r=np.linspace(root_cutout, radius_of_rotors, 100)
#delta_r=r[1]-r[0]
k=[]
k1=[]
for i in range(1,99):
  k.append(elemental_inflow_ratio(r[i])[0])
  k1.append((elemental_inflow_ratio(r[i])[0])*rotor_omega*radius_of_rotors-climb_velocity)

r=r[1:-1]
plt.plot(r)
#plt.plot(r,k1)
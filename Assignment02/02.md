# Procedure

## Input:
Weight, f, V.infty, rho, c(r), R, omega

[internal input]: phi
## Calcutions:

[der] Drag
from f and V.infty

[der] Thrust
from Drag and Weight

[der] alpha.tpp
from Drag and Weight

[der] Area
From R

[der] Ct
From rho, A, Thrust, omega, R

[der] mu (Advance ratio)
From V.infty, alpha.tpp, omega, R

[der] lambda.i.Glaubert
From mu, alpha.tpp, Ct

[der] lambda.G
From lambda.i.Glaubert, V.infty, omega, R, alpha.tpp

[der] lambda.i(r, phi)
From phi, r, R, lambda.G, lambda.i.Glaubert, mu

[der] v(r) (induced velocity)
From omega, R, lambda.i

[ITERATION LOOP]

Assume theta0, theta1s, theta1c
Constrainted that theta1s<0 and 0<theta1c<<1

- START LOOP
[der] alpha.effective(r, phi)
From theta1s, theta1c, v, omega, r, alpha.tpp

[der] beta.0 (coning angle)
Get from a, rho, R, c(r), alpha.effective(r, R). Integrated over r/R and averaged over phi

[der] Instantaneous Thrust T(omega, phi)
Using rho, V.infty, alpha.effective, v, a, c, R

[der] Thrust
Multiplying my number of blades * average of instantaneous thrust
- UPDATE theta0, theta1s, theta1c based on gradient descent.

[END ITERATION LOOP]

Output resulting values of theta.0, theta.1s, theta.1c
Use these in further post processing.

[optional] Repeat these for different Omega values




